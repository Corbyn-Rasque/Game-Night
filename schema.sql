create table
  public.teams (
    id bigint generated by default as identity not null,
    name text not null,
    created timestamp with time zone not null default now(),
    constraint teams_pkey1 primary key (id)
  ) tablespace pg_default;

create table
  public.events (
    id bigint generated by default as identity not null,
    type text not null,
    name text not null,
    location text not null,
    max_attendees bigint not null,
    start timestamp without time zone not null,
    cancelled boolean not null default false,
    stop timestamp without time zone null,
    constraint Event_pkey primary key (id)
  ) tablespace pg_default;

create table
  public.users (
    username text not null,
    first text null,
    last text null,
    id bigint generated by default as identity not null,
    constraint users_pkey primary key (id),
    constraint Users_username_key unique (username),
    constraint users_id_key unique (id)
  ) tablespace pg_default;

create table
  public.user_events (
    user_id bigint not null,
    event_id bigint not null,
    constraint user_events_pkey primary key (user_id, event_id),
    constraint user_events_event_id_fkey foreign key (event_id) references events (id),
    constraint user_events_user_id_fkey foreign key (user_id) references users (id)
  ) tablespace pg_default;

create table
  public.items_ledger (
    username text not null,
    quantity bigint not null,
    payment bigint not null,
    event_id bigint not null,
    item_name text not null,
    deleted boolean not null default false,
    constraint items_ledger_pkey primary key (username, event_id, item_name),
    constraint item_ledger_event_id_item_name_fkey foreign key (event_id, item_name) references event_items (event_id, name),
    constraint item_ledger_username_fkey foreign key (username) references users (username)
  ) tablespace pg_default;

create table
  public.games (
    id bigint generated by default as identity not null,
    name text not null,
    platform text not null,
    publisher text not null,
    release_year bigint not null,
    player_count bigint not null,
    constraint games_pkey primary key (
      id,
      name,
      platform,
      publisher,
      release_year,
      player_count
    ),
    constraint games_id_key unique (id)
  ) tablespace pg_default;

create table
  public.brackets (
    id bigint generated by default as identity not null,
    name text null,
    event_id bigint not null,
    game_id bigint null,
    time date null,
    match_size bigint not null,
    num_players bigint not null,
    constraint brackets_pkey1 primary key (id),
    constraint brackets_event_id_fkey1 foreign key (event_id) references events (id),
    constraint brackets_game_id_fkey foreign key (game_id) references games (id)
) tablespace pg_default;

create or replace function add_initial_matches()
returns trigger
language plpgsql
as $$
begin
  insert into matches (bracket_id)
  select (new.id)
  from generate_series(1, ceil(new.num_players::float / new.match_size::float)::integer);
  return new;
end;
$$;

create trigger generate_initial_matches
after insert on brackets for each row
execute function add_initial_matches ();

create table
  public.matches (
    id bigint generated by default as identity not null,
    bracket_id bigint not null,
    next_match bigint null,
    winner_id bigint null,
    constraint matches_pkey primary key (id),
    constraint matches_bracket_id_fkey foreign key (bracket_id) references brackets (id) on delete cascade,
    constraint matches_next_match_fkey foreign key (next_match) references matches (id),
    constraint matches_winner_id_fkey foreign key (winner_id) references users (id)
  ) tablespace pg_default;

create table
  public.event_items (
    event_id bigint not null,
    name text not null,
    type text null,
    requested bigint not null,
    cost bigint not null,
    deleted boolean not null default false,
    approved boolean not null default true,
    constraint event_items_pkey primary key (event_id, name)
  ) tablespace pg_default;

create table
  public.event_attendance (
    event_id bigint not null,
    user_id bigint not null,
    constraint event_attendance_pkey primary key (event_id, user_id),
    constraint event_attendance_event_id_fkey foreign key (event_id) references events (id),
    constraint event_attendance_user_id_fkey foreign key (user_id) references users (id)
  ) tablespace pg_default;

create table
  public.match_players (
    match_id bigint not null,
    player_id bigint not null,
    score bigint null,
    constraint match_players_pkey primary key (match_id, player_id),
    constraint match_players_match_id_fkey foreign key (match_id) references matches (id) on delete cascade,
    constraint match_players_player_id_fkey foreign key (player_id) references users (id)
  ) tablespace pg_default;

create or replace function enforce_match_size_limit()
returns trigger
language plpgsql
as $$
declare
  current INT;
  allowed INT;
begin
  SELECT COUNT(*)
  INTO current
  FROM match_players
  WHERE match_id = NEW.match_id;

  SELECT brackets.match_size
  INTO allowed
  FROM match_players
  JOIN matches ON matches.id = NEW.match_id
  JOIN brackets ON brackets.id = matches.bracket_id;

  IF current >= allowed THEN
    raise exception 'Cannot insert: match already full';
  END IF;
end;
$$;

create trigger check_match_size_limit before insert on match_players for each row
execute function enforce_match_size_limit ();

create table
  public.team_players (
    team_id bigint not null,
    player_id bigint not null,
    constraint team_players_pkey primary key (team_id, player_id),
    constraint team_players_player_id_fkey foreign key (player_id) references users (id) on delete cascade,
    constraint team_players_team_id_fkey foreign key (team_id) references teams (id) on delete cascade
  ) tablespace pg_default;